# AUTOGENERATED! DO NOT EDIT! File to edit: network_embeding.ipynb (unless otherwise specified).

__all__ = ['SemanticNetwork', 'get_clusters']

# Cell
import networkx as nx
from networkx.algorithms.community.label_propagation import asyn_lpa_communities
from networkx.algorithms.community import greedy_modularity_communities
import numpy as np
from scipy.cluster.hierarchy import linkage, dendrogram, fcluster
from scipy.spatial.distance import pdist, squareform
import fastcluster as fc
from collections import defaultdict, Counter
import pylab as plt

# Cell
class SemanticNetwork:
    def __init__(self,nneigh, min_sim, model):
        self.nneigh = nneigh
        self.min_sim = min_sim
        self.model = model
        self.net = nx.DiGraph()

    def _get_corpus_gen(self, corpus_file):
        corpus = (d for d in open(corpus_file,'r').readlines())
        return corpus

    def get_vectors(self, corpus_file):
        corpus = self._get_corpus_gen(corpus_file)
        vectors = np.zeros((self.model.corpus_count,self.model.dv.vector_size)) #vectors as lines
        for i,doc in enumerate(corpus):
            vectors[i,:] = self.model.infer_vector(doc.split())

        return vectors

    def get_agglomerative_cluster(self, vectors):
        clust = fc.linkage_vector(vectors, method="single", metric='cosine')
        return clust

    def grow_network(self, vectors):
        dists = pdist(vectors, metric='euclidean')
        print(dists.shape)
        sims = squareform(1/(1+dists))
        print(sims.shape)
        self.net = nx.convert_matrix.from_numpy_matrix(sims, create_using=nx.DiGraph)

    def get_communities(self, algorithm='LPA'):
        if algorithm == 'LPA':
            comms = asyn_lpa_communities(self.net)
        elif algorithm == 'mod':
            comms = greedy_modularity_communities(self.net)
        return comms







# Cell

def get_clusters(linkage, dists, threshold=0.9):
    """
    Returns cluster id for every document in the corpus
    """
    clusters = fcluster(doc_linkage, threshold*dists.max(), 'distance')
    return clusters

